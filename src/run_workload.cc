#include "run_workload.h"

#include <chrono>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <tuple>

#include "config_options.h"
#include "utils.h"

std::string buffer_file = "workload.log";
std::string stats_file = "stats.log";
std::shared_ptr<ROCKSDB_NAMESPACE::Env> env_guard;

int runWorkload(std::unique_ptr<DBEnv> &env) {
  DB *db;
  Options options;
  WriteOptions write_options;
  ReadOptions read_options;
  BlockBasedTableOptions table_options;
  FlushOptions flush_options;
  ConfigOptions config_options(options);

  configOptions(env, &options, &table_options, &write_options, &read_options,
                &flush_options, &config_options, &env_guard);
  printf("Done configuring options\n");

  if (env->is_per_op_timer) {
#define PER_OP_TIMER
  }
  if (env->is_total_timer) {
#define TOTAL_TIMER
  }

  std::shared_ptr<Buffer> buffer = std::make_unique<Buffer>(buffer_file);
  std::unique_ptr<Buffer> stats = std::make_unique<Buffer>(stats_file);

  if (env->IsDestroyDatabaseEnabled()) {
    // DestroyDB(env->kDBPath, options);
    std::cerr << "Destroying database ... done" << std::endl;
  }

  PrintExperimentalSetup(env, buffer);

  Status s = DB::Open(options, env->kDBPath, &db);
  if (!s.ok())
    std::cerr << s.ToString() << std::endl;
  assert(s.ok());

  // Clearing the system cache
  if (env->clear_system_cache) {
#ifdef __linux__
    std::cerr << "Clearing system cache ...";
    std::cerr << system("sudo sh -c 'echo 3 >/proc/sys/vm/drop_caches'")
              << " done" << std::endl;
#endif
  }

  std::ifstream workload_file;
  workload_file.open("workload.txt");
  assert(workload_file);

  size_t total_operations = 0;
  if (env->IsShowProgressEnabled()) {
    std::string line;
    while (std::getline(workload_file, line)) {
      ++total_operations;
    }
  }

  workload_file.clear();
  workload_file.seekg(0, std::ios::beg);

#ifdef PER_OP_TIMER
  unsigned long inserts_exec_time = 0, updates_exec_time = 0, pq_exec_time = 0,
                pdelete_exec_time = 0, rq_exec_time = 0;
#endif // PER_OP_TIMER

#ifdef TOTAL_TIMER
  auto exec_start = std::chrono::high_resolution_clock::now();
#endif // TOTAL_TIMER

  if (env->IsPerfStatEnabled())
    rocksdb::get_perf_context()->Reset();
  if (env->IsIOStatEnabled())
    rocksdb::get_iostats_context()->Reset();

  std::string line;
  unsigned long ith_op = 0;
  while (std::getline(workload_file, line)) {
    if (line.empty())
      break;
    bool is_last_line = (workload_file.peek() == EOF);

    std::istringstream stream(line);
    char operation;
    stream >> operation;

    switch (operation) {
      // [Insert]
    case 'I': {
      std::string key, value;
      stream >> key >> value;

#ifdef PER_OP_TIMER
      auto start = std::chrono::high_resolution_clock::now();
#endif // PER_OP_TIMER
      s = db->Put(write_options, key, value);
#ifdef PER_OP_TIMER
      auto stop = std::chrono::high_resolution_clock::now();
      auto duration =
          std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);
      (*stats) << "InsertTime: " << duration.count() << std::endl;
      inserts_exec_time += duration.count();
#endif // PER_OP_TIMER
      break;
    }
      // [Update]
    case 'U': {
      std::string key, value;
      stream >> key >> value;

#ifdef PER_OP_TIMER
      auto start = std::chrono::high_resolution_clock::now();
#endif // PER_OP_TIMER
      s = db->Put(write_options, key, value);
#ifdef PER_OP_TIMER
      auto stop = std::chrono::high_resolution_clock::now();
      auto duration =
          std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);
      (*stats) << "UpdateTime: " << duration.count() << std::endl;
      updates_exec_time += duration.count();
#endif // PER_OP_TIMER
      break;
    }
      // [PointDelete]
    case 'D': {
      std::string key;
      stream >> key;

#ifdef PER_OP_TIMER
      auto start = std::chrono::high_resolution_clock::now();
#endif // PER_OP_TIMER
      s = db->Delete(write_options, key);
#ifdef PER_OP_TIMER
      auto stop = std::chrono::high_resolution_clock::now();
      auto duration =
          std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);
      (*stats) << "DeleteTime: " << duration.count() << std::endl;
      pdelete_exec_time += duration.count();
#endif // PER_OP_TIMER
      break;
    }
      // [ProbePointQuery]
    case 'P':
    case 'Q':
     { // for tectonic, point query is P insteat of Q
      std::string key, value;
      stream >> key;

#ifdef PER_OP_TIMER
      auto start = std::chrono::high_resolution_clock::now();
#endif // PER_OP_TIMER
      s = db->Get(read_options, key, &value);
#ifdef PER_OP_TIMER
      auto stop = std::chrono::high_resolution_clock::now();
      auto duration =
          std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);
      (*stats) << "GetTime: " << duration.count() << std::endl;
      pq_exec_time += duration.count();
#endif // PER_OP_TIMER
      break;
    }
      // [ScanRangeQuery]
    case 'S': {
      std::string start_key, end_key;
      stream >> start_key >> end_key;

      ReadOptions scan_read_options = ReadOptions(read_options);
      scan_read_options.total_order_seek = true;
      Iterator *it = db->NewIterator(scan_read_options);
      assert(it->status().ok());
#ifdef PER_OP_TIMER
      auto start = std::chrono::high_resolution_clock::now();
#endif // PER_OP_TIMER

      for (it->Seek(start_key); it->Valid(); it->Next()) {
        if (it->key().ToString() >= end_key) {
          break;
        }
      }
      if (!it->status().ok()) {
        (*buffer) << it->status().ToString() << std::endl << std::flush;
      }
#ifdef PER_OP_TIMER
      auto stop = std::chrono::high_resolution_clock::now();
      auto duration =
          std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);
      (*stats) << "ScanTime: " << duration.count() << std::endl;
      rq_exec_time += duration.count();
#endif // PER_OP_TIMER
      delete it;
      break;
    }
    // [RangeDelete]
    case 'R': {
      std::string start_key, end_key;
      stream >> start_key >> end_key;
      s = db->DeleteRange(write_options, start_key, end_key);
      break;
    }
    default:
      (*buffer) << "ERROR: Case match NOT found !!" << std::endl;
      break;
    }

    ith_op += 1;
    UpdateProgressBar(env, ith_op, total_operations,
                      (int)total_operations * 0.02);
    if (is_last_line)
      break;
  }

#ifdef PROFILE
  if (env->verbosity > Verbosity::NO_PRINTS)
    (*buffer) << "=====================" << std::endl;
  LogTreeState(db, buffer, env);
  // LogRocksDBStatistics(db, options, buffer);
#endif // PROFILE

#ifdef TOTAL_TIMER
  auto total_exec_time =
      std::chrono::duration_cast<std::chrono::nanoseconds>(
          std::chrono::high_resolution_clock::now() - exec_start)
          .count();
#endif // TOTAL_TIMER

#ifdef PER_OP_TIMER
  (*buffer) << "=====================" << std::endl;
#endif // PER_OP_TIMER
#ifdef TOTAL_TIMER
  (*buffer) << "Workload Execution Time: " << total_exec_time << std::endl;
#endif // TOTAL_TIMER
#ifdef PER_OP_TIMER
  (*buffer) << "Inserts Execution Time: " << inserts_exec_time << std::endl;
  (*buffer) << "Updates Execution Time: " << updates_exec_time << std::endl;
  (*buffer) << "PointQuery Execution Time: " << pq_exec_time << std::endl;
  (*buffer) << "PointDelete Execution Time: " << pdelete_exec_time << std::endl;
  (*buffer) << "RangeQuery Execution Time: " << rq_exec_time << std::endl;
#endif // PER_OP_TIMER

  if (!s.ok())
    std::cerr << s.ToString() << std::endl;
  assert(s.ok());
  s = db->Close();
  if (!s.ok())
    std::cerr << s.ToString() << std::endl;
  assert(s.ok());

  PrintRocksDBPerfStats(env, buffer, options);
  table_options.block_cache.reset();
  options.table_factory.reset();

  // flush final stats and delete ptr
  buffer->flush();
  stats->flush();
#ifdef TOTAL_TIMER
  long long total_seconds = total_exec_time / 1e9;
  std::cerr << "\nExperiment completed in " << total_seconds / 3600 << "h "
            << (total_seconds % 3600) / 60 << "m " << total_seconds % 60 << "s "
            << std::endl;
#endif // TOTAL_TIMER
  return 0;
}